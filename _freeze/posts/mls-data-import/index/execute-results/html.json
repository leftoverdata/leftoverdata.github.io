{
  "hash": "eeb68be22f7b9063927d514f7e8fa83c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Importing Mass Layoff Statistics Data\"\nauthor: \"Dave Crawford\"\ndate: \"2025-03-02\"\ncategories: [\"Labor Statistics\", \"Implementation\"]\nimage: \"duckdb.jpg\"\n---\n\n\nThis post is part of a series about Mass Layoff Statistics data collected by the Bureau of Labor Statistics.  Check out the main post [here](../mls-data/index.qmd)\n\nWorking with obscure federal government data can be tricky.  There are always plenty of gotchas.  This Mass Layoff Statistics data is certainly no exception.  It's downloadable as a series of tab-delimited text files.  As you'll see later, some of the tables have column names and some don't.  Luckily there's some documentation included in the data release.\n\n## Downloading the data\nThe final data from this program resides at [this url](https://download.bls.gov/pub/time.series/ml/).  At the time of writing, this data cannot be downloaded programmatically.  This means that the BLS has some sort of protection against referencing the tables where they exist.  For this reason, I downloaded each text file manually and put them in a folder.  I've included a zip file [here](raw_mls.zip) in case the original data source goes away for any reason.\n\n## Reading the data\nThis data is heavily normalized and designed to be used in a database.  There are a bunch of coded columns and lookup tables.  This is pretty typical with this kind of data.  It was produced at a time when every kilobyte of data mattered for storage cost purposes.  It does add a bit of complexity to reading the data though.\n\nFor the task of reading and storing this data, I've decided to use [DuckDB](https://duckdb.org/). DuckDB is excellent at reading csvs and other structured text files.  It actually can read them in place without importing them to a database, which is super powerful.\n\nLet's start by importing DuckDB and connecting to a database.\n\n::: {#7096ead7 .cell execution_count=1}\n``` {.python .cell-code}\nimport duckdb\n\n# connect to a local DuckDB database.\nquack = duckdb.connect(\"mls.db\")\n```\n:::\n\n\nNow let's get an inventory of the csv files.\n\n::: {#73cb7e95 .cell execution_count=2}\n``` {.python .cell-code}\nimport os\n\n# folder containing the MLS text files\nfolder = \"./raw_mls\"\n\nall_text_files = os.listdir(folder)\n```\n:::\n\n\nNow we can iterate through each of the text files and use DuckDB to read the data.\n\n::: {#1ac5467e .cell execution_count=3}\n``` {.python .cell-code}\nfor text_file in all_text_files:\n    print(text_file)\n\n    # create a full path for the text file\n    text_file_path = os.path.join(folder, text_file)\n\n    # format a sql statement to read from text file\n    sql = f\"\"\"\n        SELECT \n            *\n        FROM\n            read_csv('{text_file_path}')\n    \"\"\"\n\n    # execute the sql\n    query_result = quack.sql(sql)\n\n    # print the column names that DuckDB found\n    print(query_result.columns)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nml.contacts\n['Mass Layoff Statistics Contacts']\nml.data.0.Current\n['series_id', 'year', 'period', 'value', 'footnote_codes']\nml.data.1.AllData\n['series_id', 'year', 'period', 'value', 'footnote_codes']\nml.dataelement\n['003', 'Layoff events']\nml.dataseries\n['M', 'Mass Layoff']\nml.footnote\n['footnote_code', 'footnote_text']\nml.industrybase\n['N', 'Industry data from 1995 to present (NAICS)']\nml.irc\n['irc_code', 'irc_text', 'display_level', 'selectable', 'sort_sequence']\nml.period\n['Q01', 'QTR1', '1st Quarter']\nml.series\n['series_id', 'dataseries_code', 'srd_code', 'industryb_code', 'irc_code', 'dataelement_code', 'footnote_codes', 'begin_year', 'begin_period', 'end_year', 'end_period']\nml.srd\n['column0', 'column1', 'column2', 'column3', 'column4']\n```\n:::\n:::\n\n\nThe query result object from DuckDB has a lot of interesting properties.  One that we can use is the `.columns` property.  This will let us know if each table has a header or not.\n\n## Writing to a database\nAs you probably noticed, some of the text files don't have column names or headers.  You can see that duckdb read the first row and assumed it was the header.  In this case, we'll have to specify column names.  We can create a dictionary of known column names based on the documentation that comes with the MLS data.  Note that for the *srd* table, there are actually five columns but only two in the documentation.\n\n::: {#282f17c4 .cell execution_count=4}\n``` {.python .cell-code}\ntable_columns = {\n    \"dataelement\": [\"dataelement_code\", \"dataelement_text\"],\n    \"dataseries\": [\"dataseries_code\", \"dataseries_text\"],\n    \"industrybase\": [\"industrybase_code\", \"industrybase_text\"],\n    \"period\": [\"period\", \"period_abbr\", \"period_name\"],\n    \"srd\": [\"srd_code\", \"srd_text\", \"col1\", \"col2\", \"col3\"]\n}\n```\n:::\n\n\nNow that we've created this dictionary with table names and columns, we can pass those columns into our sql statement where necessary.  We'll also modify the sql statement to create a table in our database instead of just querying the data.\n\nIn the DuckDB `read_csv` function, we can use the following parameters:\n- `sample_size` - this is helpful for determining data types.  The more rows that the function can sample, the more likely that it will guess the right data types for each column\n- `header` - This is true by default.  That's great for tables that have a header and column names.  For the other tables that don't, we'll have to set this to False.\n- `names` - When the header is set to False, we can use this to provide column names.\n\nWe'll pass those parameters into the sql statement as a string.\n\n::: {#7a8b9dae .cell execution_count=5}\n``` {.python .cell-code}\nfor text_file in all_text_files:\n    print(text_file)\n\n    # create a full path for the text file\n    text_file_path = os.path.join(folder, text_file)\n\n    # generate a table name based on the file name\n    table_name = text_file.split('.')[-1]\n\n    # use the table column dictionary\n    if table_name in table_columns:\n        params = f\", header=False, names={table_columns[table_name]}\"\n    else:\n        params = \"\"\n\n    # format the sql string\n    sql = f\"\"\"\n    CREATE OR REPLACE TABLE {table_name} AS\n    SELECT\n        *\n    FROM\n        read_csv('{text_file_path}', sample_size = 100_000_000 {params})\n\n    \"\"\"\n\n    # execute the sql statement\n    query_results = quack.sql(sql)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nml.contacts\nml.data.0.Current\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<script type=\"application/vnd.jupyter.widget-view+json\">\n{\"model_id\":\"3bcbc2a10f804daf88a1e312934a2390\",\"version_major\":2,\"version_minor\":0,\"quarto_mimetype\":\"application/vnd.jupyter.widget-view+json\"}\n</script>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nml.data.1.AllData\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<script type=\"application/vnd.jupyter.widget-view+json\">\n{\"model_id\":\"dc5f4b6121394d26bf81a39bf055a71e\",\"version_major\":2,\"version_minor\":0,\"quarto_mimetype\":\"application/vnd.jupyter.widget-view+json\"}\n</script>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nml.dataelement\nml.dataseries\nml.footnote\nml.industrybase\nml.irc\nml.period\nml.series\nml.srd\n```\n:::\n:::\n\n\nNow the data has been loaded into the DuckDB file and is ready for some analysis.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n<script src=\"https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js\" crossorigin=\"anonymous\"></script>\n"
      ],
      "include-after-body": [
        "<script type=application/vnd.jupyter.widget-state+json>\n{\"state\":{\"0595143eb5454bffa71721b1e7977c44\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"1.5.0\",\"model_name\":\"ProgressStyleModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"1.5.0\",\"_model_name\":\"ProgressStyleModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"1.2.0\",\"_view_name\":\"StyleView\",\"bar_color\":\"black\",\"description_width\":\"\"}},\"0f5eafb8d9c04f9ba15e5448aa6b20f1\":{\"model_module\":\"@jupyter-widgets/base\",\"model_module_version\":\"1.2.0\",\"model_name\":\"LayoutModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/base\",\"_model_module_version\":\"1.2.0\",\"_model_name\":\"LayoutModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"1.2.0\",\"_view_name\":\"LayoutView\",\"align_content\":null,\"align_items\":null,\"align_self\":null,\"border\":null,\"bottom\":null,\"display\":null,\"flex\":null,\"flex_flow\":null,\"grid_area\":null,\"grid_auto_columns\":null,\"grid_auto_flow\":null,\"grid_auto_rows\":null,\"grid_column\":null,\"grid_gap\":null,\"grid_row\":null,\"grid_template_areas\":null,\"grid_template_columns\":null,\"grid_template_rows\":null,\"height\":null,\"justify_content\":null,\"justify_items\":null,\"left\":null,\"margin\":null,\"max_height\":null,\"max_width\":null,\"min_height\":null,\"min_width\":null,\"object_fit\":null,\"object_position\":null,\"order\":null,\"overflow\":null,\"overflow_x\":null,\"overflow_y\":null,\"padding\":null,\"right\":null,\"top\":null,\"visibility\":null,\"width\":\"auto\"}},\"3bcbc2a10f804daf88a1e312934a2390\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"1.5.0\",\"model_name\":\"FloatProgressModel\",\"state\":{\"_dom_classes\":[],\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"1.5.0\",\"_model_name\":\"FloatProgressModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/controls\",\"_view_module_version\":\"1.5.0\",\"_view_name\":\"ProgressView\",\"bar_style\":\"\",\"description\":\"\",\"description_tooltip\":null,\"layout\":\"IPY_MODEL_4d33c8c61e9946f3968be1cb6da26c9a\",\"max\":100,\"min\":0,\"orientation\":\"horizontal\",\"style\":\"IPY_MODEL_0595143eb5454bffa71721b1e7977c44\",\"value\":100}},\"4d33c8c61e9946f3968be1cb6da26c9a\":{\"model_module\":\"@jupyter-widgets/base\",\"model_module_version\":\"1.2.0\",\"model_name\":\"LayoutModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/base\",\"_model_module_version\":\"1.2.0\",\"_model_name\":\"LayoutModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"1.2.0\",\"_view_name\":\"LayoutView\",\"align_content\":null,\"align_items\":null,\"align_self\":null,\"border\":null,\"bottom\":null,\"display\":null,\"flex\":null,\"flex_flow\":null,\"grid_area\":null,\"grid_auto_columns\":null,\"grid_auto_flow\":null,\"grid_auto_rows\":null,\"grid_column\":null,\"grid_gap\":null,\"grid_row\":null,\"grid_template_areas\":null,\"grid_template_columns\":null,\"grid_template_rows\":null,\"height\":null,\"justify_content\":null,\"justify_items\":null,\"left\":null,\"margin\":null,\"max_height\":null,\"max_width\":null,\"min_height\":null,\"min_width\":null,\"object_fit\":null,\"object_position\":null,\"order\":null,\"overflow\":null,\"overflow_x\":null,\"overflow_y\":null,\"padding\":null,\"right\":null,\"top\":null,\"visibility\":null,\"width\":\"auto\"}},\"d3f8c1b36d494806af3989ba52409600\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"1.5.0\",\"model_name\":\"ProgressStyleModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"1.5.0\",\"_model_name\":\"ProgressStyleModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"1.2.0\",\"_view_name\":\"StyleView\",\"bar_color\":\"black\",\"description_width\":\"\"}},\"dc5f4b6121394d26bf81a39bf055a71e\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"1.5.0\",\"model_name\":\"FloatProgressModel\",\"state\":{\"_dom_classes\":[],\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"1.5.0\",\"_model_name\":\"FloatProgressModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/controls\",\"_view_module_version\":\"1.5.0\",\"_view_name\":\"ProgressView\",\"bar_style\":\"\",\"description\":\"\",\"description_tooltip\":null,\"layout\":\"IPY_MODEL_0f5eafb8d9c04f9ba15e5448aa6b20f1\",\"max\":100,\"min\":0,\"orientation\":\"horizontal\",\"style\":\"IPY_MODEL_d3f8c1b36d494806af3989ba52409600\",\"value\":100}}},\"version_major\":2,\"version_minor\":0}\n</script>\n"
      ]
    }
  }
}